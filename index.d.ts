// Generated by dts-bundle-generator v9.5.1

import { ArrayOptions, NumberOptions, ObjectOptions, SchemaOptions, Static, StringOptions, TLiteral, TObject, TProperties, TSchema, TUnion } from '@sinclair/typebox';

declare class ConfigJSDriver<C extends DriverConfig, S extends DriverStore, Async extends boolean> {
	readonly identify: string;
	async: Async;
	config: C;
	data: Record<string, any>;
	private compiledSchema?;
	private _getEnvKeyForPathOverridden?;
	protected store: S;
	private _onLoad?;
	private _onGet?;
	private _onSet?;
	constructor(options: ConfigJSDriverOptions<C, S, Async>);
	load(schema?: TObject, options?: Partial<C>): inPromise<Async, void>;
	get<T = StaticSchema<any>, P extends Paths<T> = any>(path: P): inPromise<Async, DeepGet<T, P>>;
	has<T = StaticSchema<any>, P extends Paths<T> = any>(path: P): boolean;
	set<T = StaticSchema<any>, P extends Paths<T> = any>(path: P, value: DeepGet<T, P>, options?: {
		description?: string;
	}): inPromise<Async, void>;
	insert<T = StaticSchema<any>, P extends RootPaths<T> = any>(path: P, partial: Partial<DeepGet<T, P>>): inPromise<Async, void>;
	private validate;
	private _runRefines;
	private _buildConfigFromRawAsync;
	private buildConfigFromRaw;
	private coerceType;
	private _applyInitialSaves;
	private _getEnvKeyForPath;
}
export declare class ConfigJS<D extends ConfigJSDriver<any, any, any>, S extends SchemaDefinition> {
	private driver;
	private compiledSchema;
	private loaded;
	constructor(config: {
		driver: D;
		schema: S;
	});
	load(options?: D["config"]): inPromise<D["async"], void>;
	get<P extends Paths<StaticSchema<S>>>(path: P): inPromise<D["async"], DeepGet<StaticSchema<S>, P>>;
	has<P extends Paths<StaticSchema<S>>>(path: P): inPromise<D["async"], boolean>;
	root<P extends RootPaths<StaticSchema<S>>>(path: P): inPromise<D["async"], DeepGet<StaticSchema<S>, P>>;
	set<P extends Paths<StaticSchema<S>>>(path: P, value: DeepGet<StaticSchema<S>, P>, options?: {
		description?: string;
	}): inPromise<D["async"], void>;
	insert<P extends RootPaths<StaticSchema<S>>>(path: P, partial: Partial<DeepGet<StaticSchema<S>, P>>): inPromise<D["async"], void>;
	private _buildSchema;
}
/**
 * A helper object for creating schema definitions with custom metadata.
 * Includes both PascalCase and camelCase versions of helpers.
 */
export declare const c: {
	string: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	number: (options?: NumberOptions & CustomOptions) => import("@sinclair/typebox").TNumber;
	boolean: (options?: SchemaOptions & CustomOptions) => import("@sinclair/typebox").TBoolean;
	object: (properties: TProperties, options?: ObjectOptions & CustomOptions) => import("@sinclair/typebox").TObject<TProperties>;
	array: (items: TSchema, options?: ArrayOptions & CustomOptions) => import("@sinclair/typebox").TArray<TSchema>;
	record: <K extends TSchema, V extends TSchema>(key: K, value: V, options?: SchemaOptions & CustomOptions) => import("@sinclair/typebox").TRecordOrObject<K, V>;
	enum: <T extends string[] | object>(values: T, options?: CustomOptions) => TUnion<TLiteral<string>[]>;
	ip: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	ipv6: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	email: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	url: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	optional: <T extends TSchema>(schema: T) => T extends import("@sinclair/typebox").TOptional<infer S extends TSchema> ? import("@sinclair/typebox").TOptional<S> : import("@sinclair/typebox").Ensure<import("@sinclair/typebox").TOptional<T>>;
	/** Creates a String schema. */
	String: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	/** Creates a Number schema. */
	Number: (options?: NumberOptions & CustomOptions) => import("@sinclair/typebox").TNumber;
	/** Creates a Boolean schema. */
	Boolean: (options?: SchemaOptions & CustomOptions) => import("@sinclair/typebox").TBoolean;
	/** Creates an Object schema. */
	Object: (properties: TProperties, options?: ObjectOptions & CustomOptions) => import("@sinclair/typebox").TObject<TProperties>;
	/** Creates an Array schema. */
	Array: (items: TSchema, options?: ArrayOptions & CustomOptions) => import("@sinclair/typebox").TArray<TSchema>;
	/** Creates a Record schema. */
	Record: <K extends TSchema, V extends TSchema>(key: K, value: V, options?: SchemaOptions & CustomOptions) => import("@sinclair/typebox").TRecordOrObject<K, V>;
	/** Creates a Union of Literals from a string array or a TypeScript string enum. */
	Enum: <T extends string[] | object>(values: T, options?: CustomOptions) => TUnion<TLiteral<string>[]>;
	/** Creates a string schema with 'ipv4' format. */
	IP: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	/** Creates a string schema with 'ipv6' format. */
	IPv6: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	/** Creates a string schema with 'email' format. */
	Email: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	/** Creates a string schema with 'uri' format. */
	URL: (options?: StringOptions & CustomOptions) => import("@sinclair/typebox").TString;
	/** Creates an Optional schema. */
	Optional: <T extends TSchema>(schema: T) => T extends import("@sinclair/typebox").TOptional<infer S extends TSchema> ? import("@sinclair/typebox").TOptional<S> : import("@sinclair/typebox").Ensure<import("@sinclair/typebox").TOptional<T>>;
};
export declare const envDriver: ConfigJSDriver<{
	path: string;
}, DriverStore, false>;
export interface ConfigJSDriverOptions<C extends DriverConfig, S extends DriverStore, A extends boolean> {
	identify: string;
	async: A;
	config: C;
	getEnvKeyForPath?: (path: string) => string;
	onLoad?: DriverOnLoad<C, S, A>;
	onGet?: DriverOnGet<C, S, A>;
	onSet?: DriverOnSet<C, S, A>;
}
/**
 * Custom metadata properties that can be added to a schema.
 */
export interface CustomOptions {
	description?: string;
	important?: boolean;
	initial_save?: boolean;
	prop?: string;
	refines?: ((value: unknown) => boolean | string)[];
}
export type DeepGet<T, P extends string> = P extends `${infer K}.${infer R}` ? K extends keyof T ? DeepGet<T[K], R> : never : P extends keyof T ? T[P] : never;
export type DriverConfig = Record<string, unknown>;
export type DriverOnGet<C extends DriverConfig, S extends DriverStore, A extends boolean> = (this: ConfigJSDriver<C, S, A>, key: string) => inPromise<A, unknown>;
export type DriverOnLoad<C extends DriverConfig, S extends DriverStore, A extends boolean> = (this: ConfigJSDriver<C, S, A>, opts: Partial<C>) => inPromise<A, void>;
export type DriverOnSet<C extends DriverConfig, S extends DriverStore, A extends boolean> = (this: ConfigJSDriver<C, S, A>, key: string, value: unknown, options?: {
	description?: string;
}) => inPromise<A, void>;
export type DriverStore = Record<string, unknown>;
export type Paths<T> = T extends object ? {
	[K in keyof T]: K extends string ? T[K] extends object ? `${K}.${Paths<T[K]>}` : K : never;
}[keyof T] : never;
export type RootPaths<T> = T extends object ? {
	[K in keyof T]: K extends string ? T[K] extends object ? K | `${K}.${RootPaths<T[K]>}` : never : never;
}[keyof T] : never;
/**
 * A recursive type representing the user-friendly schema definition.
 */
export type SchemaDefinition = {
	[key: string]: TSchema | SchemaDefinition;
};
/**
 * A mapped type that converts a SchemaDefinition into a static TypeScript type.
 */
export type StaticSchema<T> = T extends TSchema ? Static<T> : T extends SchemaDefinition ? {
	-readonly [K in keyof T]: StaticSchema<T[K]>;
} : never;
export type inPromise<Async extends boolean, Result> = Async extends true ? Promise<Result> : Result;

export {};
