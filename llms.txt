
--- START OF FILE: src/kfg.ts ---
import { Value } from "@sinclair/typebox/value";
import { KfgStore } from "./store";
import type { KfgDriver } from "./kfg-driver";
import type {
	DeepGet,
	Paths,
	RootPaths,
	SchemaDefinition,
	StaticSchema,
	inPromise,
} from "./types";
import {
	addSmartDefaults,
	buildTypeBoxSchema,
	makeSchemaOptional,
} from "./utils/schema";
import { getProperty, setProperty } from "./utils/object";

/**
 * The main class for Kfg. It is responsible for loading and managing the configuration.
 * @template D The type of the driver.
 * @template S The type of the schema.
 */
export class Kfg<D extends KfgDriver<any, any>, S extends SchemaDefinition> {
	public driver: D;
	public schema: S;
	public $store = new KfgStore();
	private loaded = false;
	private _lastOptions: any;

	/**
	 * Creates a new instance of Kfg.
	 * @param driver The driver instance.
	 * @param schema The schema to use for validating the configuration.
	 */
	constructor(driver: D, schema: S) {
		this.driver = driver;
		this.schema = schema;
	}

	/**
	 * Returns the driver configuration from the store.
	 */
	get $config(): D["config"] {
		return this.$store.get("~driver", this.driver.config);
	}

	/**
	 * Mounts the configuration using the driver.
	 * @param options - The loading options.
	 */
	public mount(
		options?: D["config"] & {
			only_importants?: boolean;
		},
	): inPromise<D["async"], void> {
		this._lastOptions = options;
		let schemaToLoad = this.schema;
		if (options?.only_importants) {
			schemaToLoad = makeSchemaOptional(this.schema) as S;
		}

		const processResult = (result: any) => {
			const validated = this.validate(result, schemaToLoad);
			this.$store.set("data", validated);
			this.loaded = true;
		};

		const result = this.driver.mount(this, options);
		if (this.driver.async) {
			return (result as Promise<void>).then(processResult) as inPromise<
				D["async"],
				void
			>;
		}
		processResult(result);
		return undefined as inPromise<D["async"], void>;
	}

	/**
	 * Alias for mount().
	 */
	public load(
		options?: Partial<D["config"]> & {
			only_importants?: boolean;
		},
	) {
		return this.mount(options);
	}

	/**
	 * Reloads the configuration.
	 * @param options - The loading options.
	 */
	public reload(
		options?: Partial<D["config"]> & {
			only_importants?: boolean;
		},
	) {
		this.loaded = false;
		return this.mount(options || this._lastOptions);
	}

	/**
	 * Saves the configuration.
	 * @param data Optional data to save.
	 */
	public save(data?: any): inPromise<D["async"], void> {
		if (!this.loaded) {
			throw new Error("[Kfg] Config not loaded. Call mount() first.");
		}

		const run = () => {
			const currentData = this.$store.get("data");
			if (this.driver.save) {
				return this.driver.save(this as never, data || currentData);
			}
		};

		if (this.driver.async) return Promise.resolve().then(run) as any;
		return run() as any;
	}

	/**
	 * Gets a value from the configuration.
	 * @param path The path to the value.
	 * @returns The value at the given path.
	 */
	public get<P extends Paths<StaticSchema<S>>>( 
		path: P,
	): inPromise<D["async"], DeepGet<StaticSchema<S>, P>> {
		if (!this.loaded) {
			throw new Error("[Kfg] Config not loaded. Call mount() first.");
		}

		const run = () => {
			const data = this.$store.get("data", {});
			return getProperty(data, path as string);
		};

		if (this.driver.async) {
			return (this.driver.onRequest!(this as never, { path }) as Promise<void>).then(run) as inPromise<D["async"], DeepGet<StaticSchema<S>, P>>;
		}
		if (this.driver.onRequest) this.driver.onRequest(this as never, { path });
		return run() as inPromise<D["async"], DeepGet<StaticSchema<S>, P>>;
	}

	/**
	 * Checks if a value exists in the configuration.
	 * @param paths The paths to the values.
	 * @returns True if all values exist, false otherwise.
	 */
	public has<P extends Paths<StaticSchema<S>>>(
		...paths: P[]
	): inPromise<D["async"], boolean> {
		if (!this.loaded) {
			throw new Error("[Kfg] Config not loaded. Call mount() first.");
		}

		const run = () => {
			const data = this.$store.get("data", {});
			return paths.every((path) => getProperty(data, path as string) !== undefined);
		};

		if (this.driver.async) {
			return (this.driver.onRequest!(this as never, { paths }) as Promise<void>).then(run) as inPromise<D["async"], boolean>;
		}
		if (this.driver.onRequest) this.driver.onRequest(this as never, { paths });
		return run() as inPromise<D["async"], boolean>;
	}

	/**
	 * Sets a value in the configuration.
	 */
	public set<P extends Paths<StaticSchema<S>>>(
		path: P,
		value: DeepGet<StaticSchema<S>, P>,
		options?: { description?: string },
	): inPromise<D["async"], void> {
		if (!this.loaded) {
			throw new Error("[Kfg] Config not loaded. Call mount() first.");
		}

		const run = () => {
			const data = this.$store.get("data", {});
			setProperty(data, path as string, value);
			this.$store.set("data", data);

			if (this.driver.onUpdate) {
				return this.driver.onUpdate(this as never, { path, value, ...options });
			}
		};

		if (this.driver.async) {
			return (this.driver.onRequest!(this as never, { path, value, ...options }) as Promise<void>).then(
				run,
			) as inPromise<D["async"], void>;
		}
		if (this.driver.onRequest) 
			this.driver.onRequest(this as never, { path, value, ...options });
		return run() as inPromise<D["async"], void>;
	}

	/**
	 * Inserts a partial value into an object in the configuration.
	 */
	public insert<P extends RootPaths<StaticSchema<S>>>(
		path: P,
		partial: Partial<DeepGet<StaticSchema<S>, P>>,
	): inPromise<D["async"], void> {
		if (!this.loaded) {
			throw new Error("[Kfg] Config not loaded. Call mount() first.");
		}

		const run = () => {
			const data = this.$store.get("data", {});
			const target = getProperty(data, path as string);
			if (typeof target !== "object" || target === null) {
				throw new Error(`Cannot insert into non-object at path: ${path}`);
			}
			Object.assign(target, partial);
			this.$store.set("data", data);

			if (this.driver.onUpdate) {
				return this.driver.onUpdate(this as never, { path, value: target });
			}
		};

		if (this.driver.async) {
			return (this.driver.onRequest!(this as never, { path, partial }) as Promise<void>).then(run) as inPromise<D["async"], void>;
		}
		if (this.driver.onRequest) this.driver.onRequest(this as never, { path, partial });
		return run() as inPromise<D["async"], void> ;
	}

	/**
	 * Injects a partial value directly into the root configuration object.
	 */
	public inject(data: Partial<StaticSchema<S>>): inPromise<D["async"], void> {
		const run = () => {
			this.$store.merge("data", data);
			if (this.driver.onMerge) {
				return this.driver.onMerge(this as never, { data });
			}
		};

		if (this.driver.async) {
			return (this.driver.onRequest!(this as never, { data }) as Promise<void>).then(run) as inPromise<D["async"], void>;
		}

		if (this.driver.onRequest) this.driver.onRequest(this as never, { data });
		return run() as inPromise<D["async"], void>;
	}

	/**
	 * Deletes a value from the configuration.
	 */
	public del<P extends Paths<StaticSchema<S>>>( 
		path: P,
	): inPromise<D["async"], void> {
		if (!this.loaded) {
			throw new Error("[Kfg] Config not loaded. Call mount() first.");
		}

		const run = () => {
			const data = this.$store.get("data", {});
			const keys = (path as string).split(".");
			const lastKey = keys.pop()!;
			let target = data;
			for (const key of keys) {
				target = target[key];
				if (!target) return;
			}
			delete target[lastKey];
			this.$store.set("data", data);

			if (this.driver.onDelete) {
				return this.driver.onDelete(this as never, { path });
			}
		};

		if (this.driver.async) {
			return (this.driver.onRequest!(this as never, { path }) as Promise<void>).then(run) as any;
		}
		if (this.driver.onRequest) this.driver.onRequest(this as never, { path });
		return run() as any;
	}

	/**
	 * Validates data against the schema.
	 */
	private validate(data: any, schema = this.schema): any {
		const compiledSchema = buildTypeBoxSchema(schema);
		addSmartDefaults(compiledSchema);
		const configWithDefaults = Value.Default(compiledSchema, data) as any;
		Value.Convert(compiledSchema, configWithDefaults);

		if (!Value.Check(compiledSchema, configWithDefaults)) {
			const errors = [...Value.Errors(compiledSchema, configWithDefaults)];
			throw new Error(
				`[Kfg] Validation failed:\n${errors
					.map((e) => `- ${e.path}: ${e.message}`) 
					.join("\n")}`,
			);
		}
		return configWithDefaults;
	}

	/**
	 * Unmounts the driver.
	 */
	public unmount() {
		this.driver.unmount?.(this);
	}

	/**
	 * Returns cached data.
	 */
	public toJSON(): StaticSchema<S> {
		if (!this.loaded) {
			throw new Error("[Kfg] Config not loaded. Call mount() first.");
		}
		return this.$store.get("data");
	}
}
--- END OF FILE: src/kfg.ts ---

--- START OF FILE: src/index.ts ---
export * from "./drivers/env-driver";
export * from "./drivers/json-driver";
export * from "./drivers/sqlite-driver";
export * from "./factory";
export * from "./kfg";
export * from "./kfg-driver";
export * from "./old";
export * from "./types";

--- END OF FILE: src/index.ts ---

--- START OF FILE: src/old.ts ---
import { Kfg } from "./kfg";
import { KfgDriver } from "./kfg-driver";

/**
 * @deprecated Use Kfg instead.
 */
export const ConfigJS = Kfg;

/**
 * @deprecated Use KfgDriver instead.
 */
export const ConfigJSDriver = KfgDriver;

--- END OF FILE: src/old.ts ---

--- START OF FILE: src/drivers/json-driver.ts ---
import * as fs from "node:fs";
import * as path from "node:path";
import { KfgDriver } from "../kfg-driver";
import {
	deepMerge,
	flattenObject,
	getProperty,
	unflattenObject,
} from "../utils/object";
import { buildDefaultObject } from "../utils/schema";

// Recursively strips comment properties (e.g., "port:comment") from a nested data
// object and returns them in a flat map, keyed by their full path.
function stripComments(data: Record<string, any>): Record<string, string> {
	const comments: Record<string, string> = {};

	function recurse(currentData: Record<string, any>, prefix = "") {
		const keys = Object.keys(currentData);
		for (const key of keys) {
			if (key.endsWith(":comment")) {
				const dataKey = key.replace(/:comment$/, "");
				const commentPath = prefix ? `${prefix}.${dataKey}` : dataKey;
				comments[commentPath] = currentData[key];
				delete currentData[key];
			}
		}
		for (const key of keys) {
			if (
				typeof currentData[key] === "object" &&
				currentData[key] !== null &&
				!key.endsWith(":comment")
			) {
				const nestedPrefix = prefix ? `${prefix}.${key}` : key;
				recurse(currentData[key], nestedPrefix);
			}
		}
	}
	recurse(data);
	return comments;
}

function getFilePath(config: { path?: string }): string {
	return path.resolve(process.cwd(), config.path || "config.json");
}

function save(kfg: any, config: any) {
	const data = kfg.$store.get("data");
	const comments = kfg.$store.get("comments", {});

	let dataToSave: Record<string, any>;
	if (config.keyroot) {
		dataToSave = flattenObject(data);
		for (const path in comments) {
			dataToSave[`${path}:comment`] = comments[path];
		}
	} else {
		const dataWithComments = JSON.parse(JSON.stringify(data));
		for (const path in comments) {
			const keys = path.split(".");
			const propName = keys.pop() as string;
			const parentPath = keys.join(".");
			const parentObject = parentPath
				? getProperty(dataWithComments, parentPath)
				: dataWithComments;
			if (typeof parentObject === "object" && parentObject !== null) {
				parentObject[`${propName}:comment`] = comments[path];
			}
		}
		dataToSave = dataWithComments;
	}

	const filePath = getFilePath(config);
	fs.writeFileSync(filePath, JSON.stringify(dataToSave, null, 2));
}

/**
 * A driver for loading configuration from JSON files.
 */
export const JsonDriver = new KfgDriver<
	{ path?: string; keyroot?: boolean },
	false
>({
	identify: "json-driver",
	async: false,
	config: {},
	onMount(kfg, opts) {
		const cfg = { ...this.config, ...opts };
		const defaultData = buildDefaultObject(kfg.schema);
		const filePath = getFilePath(cfg);

		let loadedData: Record<string, any> = {};
		if (fs.existsSync(filePath)) {
			try {
				const fileContent = fs.readFileSync(filePath, "utf-8");
				if (fileContent) {
					loadedData = JSON.parse(fileContent);
				}
			} catch (_e) {
				/* Ignore */
			}
		}

		let comments: Record<string, string> = {};
		if (cfg.keyroot) {
			const flatData = loadedData as Record<string, any>;
			const cmts: Record<string, string> = {};
			const data: Record<string, any> = {};
			for (const key in flatData) {
				if (key.endsWith(":comment")) {
					cmts[key.replace(/:comment$/, "")] = flatData[key];
				} else {
					data[key] = flatData[key];
				}
			}
			comments = cmts;
			loadedData = unflattenObject(data);
		} else {
			comments = stripComments(loadedData);
		}

		kfg.$store.set("comments", comments);
		return deepMerge(defaultData, loadedData);
	},

	onUpdate(kfg, opts) {
		if (opts?.path && opts?.description) {
			const comments = kfg.$store.get("comments", {});
			comments[opts.path] = opts.description;
			kfg.$store.set("comments", comments);
		}
		save(kfg, this.config);
	},

	onDelete(kfg, opts) {
		if (opts?.path) {
			const comments = kfg.$store.get("comments", {});
			if (comments[opts.path]) {
				delete comments[opts.path];
				kfg.$store.set("comments", comments);
			}
		}
		save(kfg, this.config);
	},

	save(kfg) {
		save(kfg, this.config);
	},
});
--- END OF FILE: src/drivers/json-driver.ts ---

--- START OF FILE: src/drivers/env-driver.ts ---
import * as fs from "node:fs";
import * as path from "node:path";
import { KfgDriver } from "../kfg-driver";
import type { SchemaDefinition, TSchema } from "../types";
import { parse, removeEnvKey, updateEnvContent } from "../utils/env";
import { deepMerge } from "../utils/object";
import { buildDefaultObject } from "../utils/schema";

function getFilePath(config: { path?: string }): string {
	return path.resolve(process.cwd(), config.path || ".env");
}

function coerceType(value: any, schema: TSchema) {
	if (value === undefined) return undefined;

	const type = (schema as any).type;
	if (type === "number") return Number(value);
	if (type === "boolean") return String(value).toLowerCase() === "true";

	if (type === "array" && typeof value === "string") {
		const trimmedValue = value.trim();
		if (trimmedValue.startsWith("[") && trimmedValue.endsWith("]")) {
			try {
				return JSON.parse(trimmedValue);
			} catch {
				/* fallthrough */
			}
		}
	}

	return value;
}

function traverseSchema(
	schema: SchemaDefinition,
	envValues: Record<string, string>,
	prefix: string[] = [],
) {
	const builtConfig: Record<string, any> = {};

	for (const key in schema) {
		const currentPath = [...prefix, key];
		const definition = schema[key] as TSchema | SchemaDefinition;

		const isTypeBoxSchema = (def: any): def is TSchema =>
			!!def[Symbol.for("TypeBox.Kind")];

		if (isTypeBoxSchema(definition)) {
			const prop = definition.prop as string | undefined;
			const envKey = prop || currentPath.join("_").toUpperCase();

			let value: any = envValues[envKey];

			if (value === undefined) {
				value = definition.default;
			}

			if (value !== undefined) {
				builtConfig[key] = coerceType(value, definition);
			}
		} else if (typeof definition === "object" && definition !== null) {
			const nestedConfig = traverseSchema(
				definition as SchemaDefinition,
				envValues,
				currentPath,
			);
			builtConfig[key] = nestedConfig;
		}
	}

	return builtConfig;
}

/**
 * A driver for loading configuration from environment variables and .env files.
 */
export const EnvDriver = new KfgDriver<{ path?: string }, false>({
	identify: "env-driver",
	async: false,
	config: {},
	onMount(kfg, opts) {
		const cfg = { ...this.config, ...opts };
		const filePath = getFilePath(cfg);
		const fileContent = fs.existsSync(filePath)
			? fs.readFileSync(filePath, "utf-8")
			: "";
		const envFileValues = parse(fileContent);

		const processEnv = Object.fromEntries(
			Object.entries(process.env).filter(([, v]) => v !== undefined),
		) as Record<string, string>;

		const allEnvValues = { ...processEnv, ...envFileValues };

		const envData = traverseSchema(kfg.schema, allEnvValues);
		const defaultData = buildDefaultObject(kfg.schema);

		return deepMerge(defaultData, envData);
	},

	onUpdate(_kfg, opts) {
		if (!opts?.path) return;
		const envKey = opts.path.replace(/\./g, "_").toUpperCase();

		const filePath = getFilePath(this.config!);
		const currentContent = fs.existsSync(filePath)
			? fs.readFileSync(filePath, "utf-8")
			: "";
		const newContent = updateEnvContent(
			currentContent,
			envKey,
			opts.value,
			opts.description,
		);
		fs.writeFileSync(filePath, newContent);
	},

	onDelete(_kfg, opts) {
		if (!opts?.path) return;
		const envKey = opts.path.replace(/\./g, "_").toUpperCase();
		const filePath = getFilePath(this.config!);
		if (!fs.existsSync(filePath)) {
			return;
		}
		const currentContent = fs.readFileSync(filePath, "utf-8");
		const newContent = removeEnvKey(currentContent, envKey);
		fs.writeFileSync(filePath, newContent);
	},
});
--- END OF FILE: src/drivers/env-driver.ts ---

--- START OF FILE: src/drivers/sqlite-driver.ts ---
import { KfgDriver } from "../kfg-driver";
import { unflattenObject } from "../utils/object";
import { loadSqliteDatabase } from "../utils/sqlite";

const KfgDatabase = await loadSqliteDatabase();

export interface SqliteDriverConfig {
	path?: string;
	table?: string;
	database?: string | any;
}

function getDb(config: SqliteDriverConfig): any {
	if (config.database && typeof config.database.prepare === "function") {
		return config.database;
	}
	return new KfgDatabase(config.database || config.path || "config.db");
}

function ensureTable(db: any, table: string) {
	db.exec(`
        CREATE TABLE IF NOT EXISTS "${table}" (
            key TEXT,
            "group" TEXT,
            type TEXT,
            value TEXT,
            create_at INTEGER,
            update_at INTEGER,
            PRIMARY KEY (key, "group")
        )
    `);
}

function rowToValue(row: any) {
	let val = row.value;
	if (row.type === "number") val = Number(val);
	else if (row.type === "boolean") val = val === "true";
	else if (row.type === "object" || row.type === "array") {
		try {
			val = JSON.parse(val);
		} catch {
			/* ignore */
		}
	}
	return val;
}

export const SqliteDriver = new KfgDriver<SqliteDriverConfig, false>({
	identify: "sqlite-driver",
	async: false,
	config: {},
	onMount(kfg, opts) {
		const cfg = { ...this.config, ...opts };
		const db = getDb(cfg);
		kfg.$store.set("db", db);
		kfg.$store.set("queue", []);

		const table = cfg.table || "settings";
		ensureTable(db, table);

		const rows = db.prepare(`SELECT * FROM "${table}"`).all() as any[];
		const flat: Record<string, any> = {};
		for (const row of rows) {
			const fullPath = row.group ? `${row.group}.${row.key}` : row.key;
			flat[fullPath] = rowToValue(row);
		}
		return unflattenObject(flat);
	},

	onUpdate(kfg, opts) {
		const db = kfg.$store.get("db");
		if (!db || !opts.path) return;
		const table = this.config?.table || "settings";
		const parts = opts.path.split(".");
		const k = parts.pop()!;
		const g = parts.join(".");
		const value = opts.value;
		const type = Array.isArray(value) ? "array" : typeof value;
		const valStr =
			type === "object" || type === "array"
				? JSON.stringify(value)
				: String(value);
		const now = Date.now();

		const queue = kfg.$store.get("queue", []);
		queue.push(() => {
			db.prepare(
				`INSERT INTO "${table}" (key, "group", type, value, create_at, update_at)
                    VALUES (?, ?, ?, ?, ?, ?)
                    ON CONFLICT(key, "group") DO UPDATE SET
                        value = excluded.value,
                        type = excluded.type,
                        update_at = excluded.update_at`,
			).run(k, g, type, valStr, now, now);
		});
		kfg.$store.set("queue", queue);
	},

	onDelete(kfg, opts) {
		const db = kfg.$store.get("db");
		if (!db || !opts.path) return;
		const table = this.config?.table || "settings";
		const parts = opts.path.split(".");
		const k = parts.pop()!;
		const g = parts.join(".");

		const queue = kfg.$store.get("queue", []);
		queue.push(() => {
			db.prepare(`DELETE FROM "${table}" WHERE key = ? AND "group" = ?`).run(
				k,
				g,
			);
		});
		kfg.$store.set("queue", queue);
	},

	save(kfg) {
		const db = kfg.$store.get("db");
		const queue = kfg.$store.get("queue", []);
		if (!db || queue.length === 0) return;

		const transaction = db.transaction(() => {
			for (const query of queue) {
				query();
			}
		});

		transaction();
		kfg.$store.set("queue", []);
	},
});
--- END OF FILE: src/drivers/sqlite-driver.ts ---

--- START OF FILE: src/utils/schema.ts ---
import {
	type TObject,
	type TProperties,
	type TSchema,
	Type,
} from "@sinclair/typebox";
import { Value } from "@sinclair/typebox/value";
import type { SchemaDefinition } from "../types";
/**
 * Adds smart defaults to a TypeBox schema.
 * @param schemaNode The schema to add the defaults to.
 */
export function addSmartDefaults(schemaNode: TObject): void {
	if (schemaNode.type !== "object" || !schemaNode.properties) {
		return;
	}
	let allChildrenOptional = true;
	for (const key in schemaNode.properties) {
		const prop = schemaNode.properties[key];

		// Ignore Unsafe schemas (used by cfs) as they are not standard TypeBox schemas
		if (prop[Symbol.for("TypeBox.Kind") as any] === "Unsafe") {
			continue;
		}

		// Only recurse if the property is a valid TypeBox object schema
		if (prop.type === "object" && prop[Symbol.for("TypeBox.Kind") as any]) {
			addSmartDefaults(prop as TObject);
		}
		const hasDefault = prop.default !== undefined;
		// Behavioral check for optionality
		const isOptional = Value.Check(Type.Object({ temp: prop }), {});
		if (!hasDefault && !isOptional) {
			allChildrenOptional = false;
		}
	}
	if (allChildrenOptional && schemaNode.default === undefined) {
		(schemaNode as any).default = {};
	}
}
/**
 * Builds a TypeBox schema from a schema definition.
 * @param definition The schema definition.
 * @returns The TypeBox schema.
 */
export function buildTypeBoxSchema(definition: SchemaDefinition): TObject {
	if (definition[Symbol.for("TypeBox.Kind") as any] === "Object") {
		return definition as TObject;
	}

	const properties: TProperties = {};
	for (const key in definition) {
		const value = definition[key] as any;

		const isObject =
			typeof value === "object" &&
			value !== null &&
			!value[Symbol.for("TypeBox.Kind")];
		if (isObject) {
			properties[key] = buildTypeBoxSchema(value);
		} else {
			properties[key] = value as TSchema;
		}
	}
	return Type.Object(properties, { additionalProperties: true });
}

/**
 * Builds a default object from a schema definition.
 * It converts the definition to a TypeBox schema, adds smart defaults,
 * and then generates the default value using TypeBox's Value.Default.
 * This ensures that nested defaults and priorities are handled correctly.
 * @param definition The schema definition.
 * @returns The default object.
 */
export function buildDefaultObject(
	definition: SchemaDefinition,
): Record<string, any> {
	const schema = buildTypeBoxSchema(definition);
	addSmartDefaults(schema);
	return Value.Default(schema, {}) as Record<string, any>;
}

/**
 * Makes a schema optional.
 * @param definition The schema definition.
 * @returns The optional schema.
 */
export function makeSchemaOptional(
	definition: SchemaDefinition,
): SchemaDefinition {
	const newDefinition: Record<string, any> = {};
	for (const key in definition) {
		const value = (definition as any)[key];
		if (value?.[Symbol.for("TypeBox.Kind")]) {
			const schema = value as TSchema & { important?: boolean };
			const isOptional = Value.Check(Type.Object({ temp: schema }), {});
			if (schema.important || isOptional) {
				newDefinition[key] = schema;
			} else {
				newDefinition[key] = Type.Optional(schema);
			}
		} else if (typeof value === "object" && value !== null) {
			newDefinition[key] = makeSchemaOptional(value);
		} else {
			newDefinition[key] = value;
		}
	}
	return newDefinition;
}

--- END OF FILE: src/utils/schema.ts ---

--- START OF FILE: src/utils/object.ts ---
/**
 * Gets a property from an object using a dot-separated path.
 * @param obj The object to get the property from.
 * @param path The path to the property.
 * @returns The property value.
 */
export function getProperty<T extends Record<string, any>>(
	obj: T,
	path: string,
): any {
	return path.split(".").reduce((acc, key) => acc?.[key], obj);
}

/**
 * Sets a property on an object using a dot-separated path.
 * @param obj The object to set the property on.
 * @param path The path to the property.
 * @param value The value to set.
 */
export function setProperty<T extends Record<string, any>>(
	obj: T,
	path: string,
	value: any,
): void {
	const keys = path.split(".");
	const lastKey = keys.pop() as string;
	let target: any = obj;
	for (const key of keys) {
		if (target[key] === undefined || target[key] === null) {
			target[key] = {};
		} else if (typeof target[key] !== "object") {
			throw new Error(`Cannot set property on non-object at path: ${key}`);
		}
		target = target[key];
	}
	target[lastKey] = value;
}

/**
 * Checks if an item is an object.
 * @param item The item to check.
 * @returns True if the item is an object, false otherwise.
 */
export function isObject(item: any): item is Record<string, any> {
	return item !== null && typeof item === "object" && !Array.isArray(item);
}

/**
 * Deeply merges two objects.
 * @param target The target object.
 * @param source The source object.
 * @returns The merged object.
 */
export function deepMerge<T extends object, U extends object>(
	target: T,
	source: U,
): T & U {
	const output = { ...target } as T & U;

	if (isObject(target) && isObject(source)) {
		Object.keys(source).forEach((key) => {
			const sourceValue = source[key as keyof U];
			const targetValue = target[key as keyof T];

			if (isObject(sourceValue) && isObject(targetValue)) {
				(output as any)[key] = deepMerge(
					targetValue as object,
					sourceValue as object,
				);
			} else {
				(output as any)[key] = sourceValue;
			}
		});
	}

	return output;
}

/**
 * Flattens a nested object into a single-level object.
 * @param obj The object to flatten.
 * @param prefix The prefix to use for the keys.
 * @returns The flattened object.
 */
export function flattenObject(
	obj: Record<string, any>,
	prefix = "",
): Record<string, any> {
	return Object.keys(obj).reduce(
		(acc, k) => {
			const pre = prefix.length ? `${prefix}.` : "";
			if (isObject(obj[k])) {
				Object.assign(acc, flattenObject(obj[k], pre + k));
			} else {
				acc[pre + k] = obj[k];
			}
			return acc;
		},
		{} as Record<string, any>,
	);
}

/**
 * Unflattens a single-level object into a nested object.
 * @param obj The object to unflatten.
 * @returns The unflattened object.
 */
export function unflattenObject(obj: Record<string, any>): Record<string, any> {
	const result = {};
	for (const key in obj) {
		setProperty(result, key, obj[key]);
	}
	return result;
}

/**
 * Deletes a property from an object using a dot-separated path.
 * @param obj The object to delete the property from.
 * @param path The path to the property.
 * @returns True if the property was deleted, false otherwise.
 */
export function deleteProperty<T extends Record<string, any>>(
	obj: T,
	path: string,
): boolean {
	const keys = path.split(".");
	const lastKey = keys.pop() as string;
	let target: any = obj;
	for (const key of keys) {
		if (target?.[key] === undefined) {
			return false;
		}
		target = target[key];
	}
	if (typeof target === "object" && target !== null) {
		return delete target[lastKey];
	}
	return false;
}

--- END OF FILE: src/utils/object.ts ---

--- START OF FILE: src/utils/env.ts ---
/**
 * Parses a .env file content string into a key-value object.
 * This version uses a simpler regex and post-processing for clarity.
 * Note: Does not support multi-line values.
 * @param content The string content of the .env file.
 * @returns A record of key-value pairs.
 */
export function parse(content: string): Record<string, string> {
	const result: Record<string, string> = {};
	const lines = content.split(/\r?\n/);

	for (const line of lines) {
		const trimmedLine = line.trim();
		if (!trimmedLine || trimmedLine.startsWith("#")) {
			continue;
		}

		const match = trimmedLine.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(.*)$/);
		if (!match) continue; // Ignore invalid lines as per common implementations

		const [, key, rawValue] = match;
		let value = rawValue.trim();

		// Strip end-of-line comments, unless in quotes
		if (!value.startsWith('"') && !value.startsWith("'")) {
			const commentIndex = value.indexOf("#");
			if (commentIndex > -1) {
				value = value.substring(0, commentIndex).trim();
			}
		}

		// Unquote values
		if (value.startsWith("'") && value.endsWith("'")) {
			value = value.substring(1, value.length - 1);
		} else if (value.startsWith('"') && value.endsWith('"')) {
			value = value.substring(1, value.length - 1);
		}

		result[key] = value;
	}
	return result;
}

/**
 * Updates a .env file content string with a new key-value pair.
 * Preserves comments and formatting.
 * @param content The original file content.
 * @param key The key to update.
 * @param value The new value.
 * @param description Optional description to add as a comment.
 * @returns The updated file content.
 */
export function updateEnvContent(
	content: string,
	key: string,
	value: unknown,
	description?: string,
): string {
	const lines = content.split(/\r?\n/);
	let keyFound = false;
	const newLines = [...lines];

	let formattedValue: string;
	if (Array.isArray(value)) {
		formattedValue = JSON.stringify(value);
	} else {
		const stringValue = String(value);
		formattedValue = /[\s"'#]/.test(stringValue)
			? `"${stringValue.replace(/"/g, '"').replace(/\n/g, "\\n")}"`
			: stringValue;
	}

	let lineIndex = -1;
	for (let i = 0; i < lines.length; i++) {
		if (new RegExp(`^s*${key}s*=s*`).test(lines[i])) {
			keyFound = true;
			lineIndex = i;
			break;
		}
	}

	if (keyFound) {
		// Key exists, update it.
		newLines[lineIndex] = `${key}=${formattedValue}`;
		// Check for description and add if it's not there.
		if (description) {
			const comment = `# ${description}`;
			if (
				lineIndex === 0 ||
				!newLines[lineIndex - 1].trim().startsWith(comment)
			) {
				if (lineIndex > 0 && !newLines[lineIndex - 1].trim().startsWith("#")) {
					newLines.splice(lineIndex, 0, comment);
				}
			}
		}
	} else {
		// Key doesn't exist, add it to the end.
		if (newLines[newLines.length - 1] !== "") {
			newLines.push(""); // Add a blank line for separation
		}
		if (description) {
			newLines.push(`# ${description}`);
		}
		newLines.push(`${key}=${formattedValue}`);
	}

	return newLines.join("\n");
}

/**
 * Removes a key from a .env file content string.
 * @param content The original file content.
 * @param key The key to remove.
 * @returns The updated file content.
 */
export function removeEnvKey(content: string, key: string): string {
	const lines = content.split(/\r?\n/);
	const keyRegex = new RegExp(`^\\s*${key}\\s*=\\s*`);
	const newLines: string[] = [];

	for (const line of lines) {
		if (keyRegex.test(line)) {
			// key found, don't add it.
			// if last line in newLines is a comment, remove it.
			if (
				newLines.length > 0 &&
				newLines[newLines.length - 1].trim().startsWith("#")
			) {
				newLines.pop();
			}
		} else {
			newLines.push(line);
		}
	}
	return newLines.join("\n");
}

--- END OF FILE: src/utils/env.ts ---

--- START OF FILE: src/utils/sqlite.ts ---
import type { Statement } from "bun:sqlite";
import { existsSync, mkdirSync } from "node:fs";
import { dirname } from "node:path";

type BunSqlite = typeof import("bun:sqlite").Database;
type NodeSqlite = typeof import("node:sqlite").DatabaseSync;
type BetterSqlite = typeof import("better-sqlite3");

export async function loadSqliteDatabase() {
	const firsttry = typeof Bun !== "undefined" ? "bun:sqlite" : "node:sqlite";
	let sqlite: BunSqlite | NodeSqlite | BetterSqlite;
	let moduleType: string;

	try {
		if (firsttry === "bun:sqlite") {
			const m = await import("bun:sqlite");
			sqlite = m.Database;
			moduleType = "bun:sqlite";
		} else {
			const m = await import("node:sqlite");
			sqlite = m.DatabaseSync;
			moduleType = "node:sqlite";
		}
	} catch {
		try {
			// not supported use module better-sqlite3
			const m = await import("better-sqlite3");
			sqlite = m?.default || m;
			moduleType = "better-sqlite3";
		} catch {
			throw new Error(
				"Bun, node and better-sqlite3 database not found, update your environment",
			);
		}
	}

	return class KfgDatabase {
		db:
			| InstanceType<BunSqlite | NodeSqlite>
			| import("better-sqlite3").Database;
		module_type: string;

		constructor(path: string) {
			this.module_type = moduleType;
			const dir = dirname(path);
			if (!existsSync(dir) && path !== ":memory:") {
				mkdirSync(dir, { recursive: true });
			}

			this.db = new sqlite(path);
		}

		exec(sql: string): void {
			this.db.exec(sql);
		}

		prepare(sql: string) {
			const stmt = (this.db as any).prepare(sql) as Statement;

			return {
				all: (...params: any[]) => {
					return stmt.all(...params);
				},
				get: (...params: any[]) => {
					return stmt.get(...params);
				},
				run: (...params: any[]) => {
					return stmt.run(...params);
				},
				finalize: () => {
					if ("finalize" in stmt) stmt.finalize();
				},
			};
		}

		close() {
			this.db.close();
		}
	};
}

--- END OF FILE: src/utils/sqlite.ts ---

--- START OF FILE: src/kfg-driver.ts ---
import type {
	Driver,
	DriverConfig,
	inPromise,
} from "./types";
import {
	deleteProperty,
	getProperty,
	setProperty,
} from "./utils/object";

/**
 * The base class for all drivers.
 * @template C The type of the driver configuration.
 * @template Async The type of the async flag.
 */
export class KfgDriver<C extends DriverConfig, Async extends boolean>
	implements Driver<Async, C>
{
	public readonly identify: string;
	public async: Async;
	public config: C;

	// Hooks from the Driver interface
	public onMount?: Driver<Async, C>["onMount"];
	public onUnmount?: Driver<Async, C>["onUnmount"];
	public onRequest?: Driver<Async, C>["onRequest"];
	public onGet?: Driver<Async, C>["onGet"];
	public onUpdate?: Driver<Async, C>["onUpdate"];
	public onDelete?: Driver<Async, C>["onDelete"];
	public onMerge?: Driver<Async, C>["onMerge"];
	public onHas?: Driver<Async, C>["onHas"];
	public onInject?: Driver<Async, C>["onInject"];
	public onToJSON?: Driver<Async, C>["onToJSON"];
	public save?: Driver<Async, C>["save"];

	/**
	 * Creates a new instance of KfgDriver.
	 * @param definition The driver definition.
	 */
	constructor(public readonly definition: Driver<Async, C>) {
		this.identify = definition.identify;
		this.async = definition.async;
		this.config = (definition.config || {}) as C;

		this.onMount = definition.onMount;
		this.onUnmount = definition.onUnmount;
		this.onRequest = definition.onRequest;
		this.onGet = definition.onGet;
		this.onUpdate = definition.onUpdate;
		this.onDelete = definition.onDelete;
		this.onMerge = definition.onMerge;
		this.onHas = definition.onHas;
		this.onInject = definition.onInject;
		this.onToJSON = definition.onToJSON;
		this.save = definition.save;
	}

	/**
	 * Mounts the driver.
	 */
	public mount(kfg: any, opts?: any): inPromise<Async, any> {
		if (this.onMount) {
			return this.onMount(kfg, opts);
		}
		return (this.async ? Promise.resolve() : undefined) as any;
	}

	/**
	 * Unmounts the driver.
	 */
	public unmount(kfg: any): void {
		if (this.onUnmount) {
			this.onUnmount(kfg);
		}
	}

	/**
	 * Called before an operation.
	 */
	public request(kfg: any, opts: any): inPromise<Async, void> {
		if (this.onRequest) {
			return this.onRequest(kfg, opts);
		}
		return (this.async ? Promise.resolve() : undefined) as any;
	}

	public get(kfg: any, key?: string): inPromise<Async, any> {
		const run = () => {
			if (this.onGet) {
				return this.onGet(kfg, { path: key });
			}
			const data = kfg.$store.get("data", {});
			if (!key) return data;
			return getProperty(data, key);
		};

		if (this.async) {
			return this.request(kfg, { path: key }).then(run) as any;
		}
		this.request(kfg, { path: key });
		return run() as any;
	}

	public set(
		kfg: any,
		key: string,
		value: any,
		options?: { description?: string },
	): inPromise<Async, void> {
		const run = () => {
			const data = kfg.$store.get("data", {});
			setProperty(data, key, value);
			kfg.$store.set("data", data);

			if (this.onUpdate) {
				return this.onUpdate(kfg, { path: key, value, ...options });
			}
		};

		if (this.async) {
			return this.request(kfg, { path: key, value, ...options }).then(
				run,
			) as any;
		}
		this.request(kfg, { path: key, value, ...options });
		return run() as any;
	}

	public has(kfg: any, ...keys: string[]): inPromise<Async, boolean> {
		const run = () => {
			if (this.onHas) {
				return this.onHas(kfg, { paths: keys });
			}
			const data = kfg.$store.get("data", {});
			return keys.every((key) => getProperty(data, key) !== undefined);
		};

		if (this.async) {
			return this.request(kfg, { paths: keys }).then(run) as any;
		}
		this.request(kfg, { paths: keys });
		return run() as any;
	}

	public del(kfg: any, key: string, options?: any): inPromise<Async, void> {
		const run = () => {
			const data = kfg.$store.get("data", {});
			deleteProperty(data, key);
			kfg.$store.set("data", data);

			if (this.onDelete) {
				return this.onDelete(kfg, { path: key, ...options });
			}
		};

		if (this.async) {
			return this.request(kfg, { path: key, ...options }).then(run) as any;
		}
		this.request(kfg, { path: key, ...options });
		return run() as any;
	}

	public saveTo(kfg: any, data?: any): inPromise<Async, void> {
		const run = () => {
			if (this.save) {
				return this.save(kfg, data);
			}
		};
		if (this.async) {
			return this.request(kfg, { data }).then(run) as any;
		}
		this.request(kfg, { data });
		return run() as any;
	}

	public inject(kfg: any, data: any): inPromise<Async, void> {
		const run = () => {
			kfg.$store.merge("data", data);
			if (this.onMerge) {
				return this.onMerge(kfg, { data });
			}
			if (this.onInject) {
				return this.onInject(kfg, { data });
			}
		};

		if (this.async) {
			return this.request(kfg, { data }).then(run) as any;
		}
		this.request(kfg, { data });
		return run() as any;
	}

	public toJSON(kfg: any): inPromise<Async, any> {
		const run = () => {
			if (this.onToJSON) {
				return this.onToJSON(kfg);
			}
			return kfg.$store.get("data");
		};
		if (this.async) {
			return this.request(kfg, {}).then(run) as any;
		}
		this.request(kfg, {});
		return run() as any;
	}
}

--- END OF FILE: src/kfg-driver.ts ---

--- START OF FILE: src/types.ts ---
import type {
	SchemaOptions,
	Static,
	TAny,
	TObject,
	TSchema,
} from "@sinclair/typebox";
import type { Kfg } from "./kfg";
import type { KfgDriver } from "./kfg-driver";
export type { TSchema, TObject, SchemaOptions };

// --- Driver Related Types ---

/**
 * Represents a path to a value in an object.
 * @template T The type of the object.
 */
export type Paths<T> = T extends object
	? {
		[K in keyof T]: K extends string
		? T[K] extends ReadonlyArray<any>
		? K
		: T[K] extends object
		? `${K}.${Paths<T[K]>}` | K
		: K
		: never;
	}[keyof T]
	: never;

/**
 * Represents a path to a value in an object.
 * @template T The type of the object.
 */
export type RootPaths<T> = T extends object
	? {
		[K in keyof T]: K extends string
		? T[K] extends ReadonlyArray<any>
		? K
		: T[K] extends object
		? K | `${K}.${RootPaths<T[K]>}`
		: never
		: never;
	}[keyof T]
	: never;

/**
 * Gets the type of a value at a given path in an object.
 * @template T The type of the object.
 * @template P The path to the value.
 */
export type DeepGet<T, P extends string> = P extends `${infer K}.${infer R}`
	? K extends keyof T
	? DeepGet<T[K], R>
	: never
	: P extends keyof T
	? T[P]
	: never;

/**
 * Represents a value that can be a promise or a plain value.
 * @template Async The type of the async flag.
 * @template Result The type of the result.
 */
export type inPromise<Async extends boolean, Result> = Async extends true
	? Promise<Result>
	: Result;

/**
 * Represents the configuration of a driver.
 */
export type DriverConfig = Record<any, any>;

/**
 * The interface for a Driver definition.
 */
export interface Driver<AsyncDriver extends boolean, Config extends DriverConfig = {}> {
	identify: string;
	async: AsyncDriver;
	config?: Partial<Config>;
	onMount?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, opts?: any) => inPromise<AsyncDriver, any>;
	onUnmount?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>) => void;
	onRequest?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, opts: any) => inPromise<AsyncDriver, void>;
	onGet?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, opts: any) => inPromise<AsyncDriver, any>;
	onUpdate?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, opts: any) => inPromise<AsyncDriver, void>;
	onDelete?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, opts: any) => inPromise<AsyncDriver, void>;
	onMerge?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, opts: any) => inPromise<AsyncDriver, void>;
	onHas?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, opts: any) => inPromise<AsyncDriver, boolean>;
	onInject?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, opts: any) => inPromise<AsyncDriver, void>;
	onToJSON?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>) => inPromise<AsyncDriver, any>;
	save?: (kfg: Kfg<KfgDriver<Config, AsyncDriver>, Record<string, TAny>>, data?: any) => inPromise<AsyncDriver, void>;
}

// --- Schema Related Types ---

/**
 * A recursive type representing the user-friendly schema definition.
 */
export type SchemaDefinition =
	| TSchema // Qualquer schema TypeBox válido (string, number, array, etc.)
	| {
		[key: string]: SchemaDefinition;
	};
/**
 * A mapped type que converte um SchemaDefinition em tipo estático TypeScript.
 * Agora com suporte a arrays do TypeBox.
 */
export type StaticSchema<T> =
	// Se for um array TypeBox, transforma no tipo do item[]
	T extends { type: "array"; items: infer I }
	? StaticSchema<I>[]
	: // Se for qualquer TSchema simples
	T extends TSchema
	? Static<T>
	: // Se for um objeto SchemaDefinition, aplica recursivamente
	T extends SchemaDefinition
	? { -readonly [K in keyof T]: StaticSchema<T[K]> }
	: never;

/**
 * Custom metadata properties that can be added to a schema.
 */
export interface CustomOptions<Default = any> {
	description?: string;
	default?: Default;
	important?: boolean;
	initial_save?: boolean;
	prop?: string;
	refines?: ((value: unknown) => boolean | string)[];
	createms?: boolean;
}
--- END OF FILE: src/types.ts ---

--- START OF FILE: src/store.ts ---
import { deepMerge } from "./utils/object";

export class KfgStore {
	private map = new Map<string, any>();

	public get<T>(key: string, defaultValue?: T): T {
		return (this.map.get(key) ?? defaultValue) as T;
	}

	public set<T>(key: string, value: T): void {
		this.map.set(key, value);
	}

	public merge<T extends object>(key: string, value: Partial<T>): void {
		const current = this.get<T>(key, {} as T);
		this.set(key, deepMerge(current, value));
	}

	public insert<T extends object>(key: string, value: Partial<T>): void {
		const current = this.get<T>(key, {} as T);
		Object.assign(current as any, value);
		this.set(key, current);
	}
}

--- END OF FILE: src/store.ts ---

--- START OF FILE: src/factory.ts ---
import {
	type ArrayOptions,
	type NumberOptions,
	type ObjectOptions,
	type SchemaOptions,
	type StringOptions,
	type TLiteral,
	type TProperties,
	type TSchema,
	type TUnion,
	Type,
} from "@sinclair/typebox";
import type { CustomOptions } from "./types";

// Helper function to extract values from string arrays, const arrays, or enums
function getEnumValues<T extends readonly (string | number)[] | object>(
	values: T,
): (string | number)[] {
	if (Array.isArray(values)) {
		return values as (string | number)[];
	}
	// For enums, filter out numeric keys if it's a numeric enum
	const isNumericEnum = Object.values(values).some(
		(v) => typeof v === "number",
	);
	if (isNumericEnum) {
		return Object.values(values).filter(
			(v) => typeof v === "number",
		) as number[];
	}
	return Object.values(values).filter((v) => typeof v === "string") as string[];
}

const _c = {
	/** Creates a String schema. */
	String: <TDefault extends string>(
		options?: StringOptions & CustomOptions<TDefault>,
	) => Type.String(options),

	/** Creates a Number schema. */
	Number: <TDefault extends number>(
		options?: NumberOptions & CustomOptions<TDefault>,
	) => Type.Number(options),

	/** Creates a Boolean schema. */
	Boolean: <TDefault extends boolean>(
		options?: Omit<SchemaOptions, "default"> & CustomOptions<TDefault>,
	) => Type.Boolean(options),

	/** Creates an Object schema. */
	Object: <
		Properties extends TProperties,
		TDefault extends Record<string, any>,
	>(
		properties: Properties,
		options?: ObjectOptions & CustomOptions<TDefault>,
	) => Type.Object(properties, options),

	/** Creates an Array schema. */
	Array: <Schema extends TSchema, TDefault extends any[]>(
		items: Schema,
		options?: ArrayOptions & CustomOptions<TDefault>,
	) => Type.Array(items, options),

	/** Creates a Record schema. */
	Record: <
		K extends TSchema,
		V extends TSchema,
		TDefault extends Record<string, any>,
	>(
		key: K,
		value: V,
		options?: Omit<SchemaOptions, "default"> & CustomOptions<TDefault>,
	) => Type.Record(key, value, options),

	/** Creates a Union of Literals from a string array, const array, or a TypeScript enum. */
	Enum: <
		T extends readonly (string | number)[] | object,
		TValues = T extends readonly (infer U)[]
			? U
			: T extends object
				? T[keyof T]
				: never,
	>(
		values: T,
		options?: CustomOptions<TValues> & Omit<SchemaOptions, "default">,
		//@ts-expect-error ignore
	): TUnion<TLiteral<TValues>[]> => {
		const enumValues = getEnumValues(values);
		return Type.Union(
			enumValues.map((v) => Type.Literal(v)),
			options,
			//@ts-expect-error ignore
		) as TUnion<TLiteral<TValues>[]>;
	},

	/** Creates a string schema with 'ipv4' format. */
	IP: <TDefault extends string>(
		options?: StringOptions & CustomOptions<TDefault>,
	) => Type.String({ ...options, format: "ipv4" }),

	/** Creates a string schema with 'ipv6' format. */
	IPv6: <TDefault extends string>(
		options?: StringOptions & CustomOptions<TDefault>,
	) => Type.String({ ...options, format: "ipv6" }),

	/** Creates a string schema with 'email' format. */
	Email: <TDefault extends string>(
		options?: StringOptions & CustomOptions<TDefault>,
	) => Type.String({ ...options, format: "email" }),

	/** Creates a string schema with 'uri' format. */
	URL: <TDefault extends string>(
		options?: StringOptions & CustomOptions<TDefault>,
	) => Type.String({ ...options, format: "uri" }),

	/** Creates an Any schema. */
	Any: () => Type.Any(),

	/** Creates an Optional schema. */
	Optional: <Schema extends TSchema>(schema: Schema) => Type.Optional(schema),

	/** Creates a Number schema that defaults to a random value if not provided. */
	Random: (options?: NumberOptions & { max?: number }) => {
		const { max = 100, ...rest } = options || {};
		return Type.Number({
			...rest,
			[Symbol.for("isRandom")]: true,
			max,
		});
	},

	/** Creates a Model relation schema. */
	Model: (
		model: any,
		resolver?: (instance: any) => any,
		options?: CustomOptions<any>,
	) => {
		return Type.Any({
			...options,
			model,
			resolver,
		});
	},

	/** Creates a number schema that defaults to current timestamp in ms. */
	createms: (options?: NumberOptions & CustomOptions<number>) => {
		return Type.Number({
			...options,
			createms: true,
			default: Date.now(),
		});
	},
};

/**
 * A helper object for creating schema definitions with custom metadata.
 * Includes both PascalCase and camelCase versions of helpers.
 */
export const c = {
	..._c,
	string: _c.String,
	number: _c.Number,
	boolean: _c.Boolean,
	object: _c.Object,
	array: _c.Array,
	record: _c.Record,
	enum: _c.Enum,
	ip: _c.IP,
	ipv6: _c.IPv6,
	email: _c.Email,
	url: _c.URL,
	any: _c.Any,
	optional: _c.Optional,
	random: _c.Random,
	model: _c.Model,
	createms: _c.createms,
};
export const k = c;
export const m = c;

--- END OF FILE: src/factory.ts ---
